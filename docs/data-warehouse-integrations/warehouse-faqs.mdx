---
# slug: "/docs/data-warehouse-integrations/warehouse-faqs"
title: "FAQ"
description: >-
  Commonly-asked questions for the RudderStack data warehouse integrations.
---

# FAQ

### When does Rudderstack load data into the data warehouse(s)?

Rudderstack lets you choose when to sync the latest data into the warehouse. The default time is 30 minutes, however you can choose to extend this value upto 24 hours. You can also configure the time at which the data needs to be loaded.

### Is there a way to force load my data into the warehouses?

Yes, there is - you can configure the below values in your `config.yaml` file:

```
#If set to true this will ignore syncFrequency and syncStartingAt values which are configured in UI. By default this is false.
warehouseSyncFreqIgnore = true 
#This field lets you control syncPeriod if the above field set to true.
uploadFreqInS=1800 
```

### Where can I view the status of my data load?

The warehouse upload status can be viewed in **Live Events** section of the destination in the RudderStack dashboard.

### Can I change the namespace (schema name) of my data warehouse in RudderStack?

Yes, you can. Although the default namespace will be the source name with some modifications to it, RudderStack also provides an option in the dashboard to explicitly set the namespace of the dataset in the warehouse.

<div class="infoBlock">

Refer to the warehouse-specific destination settings to configure a namespace in the RudderStack dashboard.
</div>

### How can I achieve identity resolution with multiple sources connected to one warehouse destination?

The default namespace will be the source name with some modifications. This will cause issues while creating mappings for Identity Resolution across different sources, leading to multiple `RUDDER_ID` being created for the same user.

To avoid this, simply match the namespace for each source.

<img src="../assets/screenshot-2021-04-21-at-6.08.10-am.png" />

This will ensure that the mappings are on the consistent namespace and only one `RUDDER_ID` is created for each user no matter how many sources are connected to your warehouse destination.

### How can I delete the staging files in my buckets?

RudderStack loads all the events configured with your warehouse into staging buckets. You can set a retention policy to delete these files from the staging bucket after a certain amount of time. If no retention policy is set, the files will keep on accumulating.

Make sure that the duration of retention policy is longer than the warehouse sync frequency duration. The reason being that RudderStack can re-run event uploads for a longer time, if required. It is recommeded to set the retention policy duration to **30 days/1 month**. 

### Which IPs should I whitelist?

You will need to whitelist the following RudderStack IPs to enable network access:

- 3.216.35.97
- 34.198.90.241
- 54.147.40.62
- 23.20.96.9
- 18.214.35.254
- 35.83.226.133
- 52.41.61.208
- 44.227.140.138
- 54.245.141.180

The EU cluster IPs are listed below:

- 3.66.99.198
- 3.64.201.167

<div class="infoBlock">

All the outbound traffic is routed through these RudderStack IPs.
</div>

### How do I avoid lags in data syncs while heavy loads are running on my data warehouse?

You can use either of the following approaches to avoid data sync lags in your warehouse:

- **Approach 1**: In the warehouse destination connection settings, set an **exclusion window** which lets you set a start and end time when Rudderstack will not sync data to your warehouse. You can run heavy loads during this time interval.

<img src="../assets/warehouse-destinations/exclusion-window.png" />

- **Approach 2**: In the warehouse destination connection settings, your can increase the **sync frequency** interval so that there are lesser number of warehouse syncs throughout the day. You can also run the data syncs during the non-peak hours by setting the **Sync Starting At** time interval.

<img src="../assets/warehouse-destinations/sync-frequency.png" />

- **Approach 3**: If you are performing only writes/updates on your data warehouse, you can set up a read replica of your database and connect it to your load generation tool. Connect the read/write replica to RudderStack, as shown:

<img src="../assets/warehouse-destinations/read-write-database.png" />

### How can I speed-up my warehouse uploads?

You can speed-up your warehouse uploads by using the following parameters:

<table style="width:100%">
  <tr>
    <th style="width:300px">Parameter</th>
    <th>Description</th>
     <th>Tip</th>
    <th>Default value</th>
  </tr>
  <tr>
    <td style="width:300px"><code class="inline-code">RSERVER_WAREHOUSE_REDSHIFT_MAX_PARALLEL_LOADS</code></td>
    <td>Defines the number of concurrent tables that are synced to redshift in a given upload.</td>
    <td>Increase this as per your infra capability.</td>
    <td><code class="inline-code">3</code></td>
  </tr>
  <tr>
    <td style="width:300px"><code class="inline-code">RSERVER_WAREHOUSE_STAGING_FILES_BATCH_SIZE</code></td>
    <td>Defines the number of staging files that are batched and synced in a single upload.</td>
    <td>Increase this to batch together more files and reduce the number of uploads needed for a given volume of data.</td>
    <td><code class="inline-code">960</code></td>
  </tr>
  <tr>
    <td style="width:300px"><code class="inline-code">RSERVER_WAREHOUSE_NO_OF_WORKERS</code></td>
    <td>Number of concurrent uploads to a warehouse. For example, 8 uploads to different schemas in Redshift can be done simultaneously.</td>
    <td>-</td>
    <td><code class="inline-code">8</code></td>
  </tr>
   <tr>
    <td style="width:300px"><code class="inline-code">warehouse_slave.replicaCount</code></td>
    <td>Number of warehouse slaves (responsible for load file generation) when the warehouse is run as separate service in Kubernetes.</td>
    <td>Increase this for speeding up the load file generation step of the upload.</td>
    <td><code class="inline-code">2</code></td>
  </tr>
   <tr>
    <td style="width:300px"><code class="inline-code">RSERVER_WAREHOUSE_NO_OF_SLAVE_WORKER_ROUTINES</code></td>
    <td>Number of go-routines creating load files in a warehouse slave process.</td>
    <td>Increase or decrease this as per memory allocated to the warehouse slave pod.</td>
    <td><code class="inline-code">4</code></td>
  </tr>
</table>

### How namespace get’s populated for WareHouse?

 Namespace + Database configuration is present

- For clickhouse destination, we pick the database configuration.
- For other destinations, if namespace is specified we pick it up.

RSERVER_WAREHOUSE_(**DEST_TYPE**)_CUSTOM_DATA_SET_PREFIX

- If this is present, we provide the namespace as (DEST_TYPE)_(CUSTOM_DATA_SET_PREFIX)_(SOURCE_NAME)
- Examples:

```
Environment:
RSERVER_WAREHOUSE_RS_CUSTOM_DATA_SET_PREFIX=”<some_random_value>”
RSERVER_WAREHOUSE_SNOWFLAKE_CUSTOM_DATA_SET_PREFIX=”<some_random_value>”

Output:
RS_<some_random_value>_<source_name>
SNOWFLAKE_<some_random_value>_<source_name>
```

IF NOTHING IS SPECIFIED

- On first sync execution, we persist the namespace for the given connection (source,destination) and for subsequent syncs, we continue using the same namespace.
- We pick the source name if no namespace is configured.


### How Rudderstack configures table names and column names?

Table names

```json
{
  "userId": "user123",
  "event": "Product Purchased",
  "properties": {
    "name": "Rubik's Cube",
    "revenue": 4.99
  },
  "context": {
    "ip": "14.5.67.21"
  },
  "timestamp": "2020-02-02T00:23:09.544Z"
}
```
- Table names follow’s snake case convention. Here in this particular case, it get’s converted to **product_purchased.**

Truncation logic:

- For DataLake (**S3 DATALAKE, GCS DATALAKE, AZURE DATALAKE**) destinationS, there is not limit being set.
- For **postgres destination,** it is limited to 63 characters.
- For **others destination**, it is limited to 127 characters.

column names
### How RudderStack normalizes Arrays and Complex event properties in the warehouse schema?

RudderStack flattens event properties and converts to snake case convention and each of these event properties will act as a columns for the warehouse.

1. Normal properties

Input

```json
{
  product: {
    name: "iPhone",
    version: 11
  }
}
```


Output

```json
1. product_name : "iPhone"
2. product_version : 11
```

2. Array properties

Input

```json
{
  products: [
    {
      name: "iPhone",
      version: 11
    },
    {
      name: "Android",
      version: 16
    }
  ]
}
```


Output

```json
1. products: "[{ \"name\": \"iPhone\", \"version\": 11  },  { \"name\": \"Android\", \"version\": 16  }]"
```

3. Complex properties

Input

```json
{
  products: {
    iPhone: {
      version: 11
    },
    Android: {
      version: 16
    }
  }
}
```


Output

```json
1. products_i_phone_version : 11
2. products_android_version : 16
```

## Contact us

For any other queries on the RudderStack warehouse integrations, you can [contact us](mailto:%20docs@rudderstack.com) or start a conversation in our [Slack](https://rudderstack.com/join-rudderstack-slack-community) community.
